import gmpy2
from Crypto.Util.number import long_to_bytes, bytes_to_long, getStrongPrime, inverse
from Crypto.Util.Padding import pad, unpad

n = 30004084769852356813752671105440339608383648259855991408799224369989221653141334011858388637782175392790629156827256797420595802457583565986882788667881921499468599322171673433298609987641468458633972069634856384101309327514278697390639738321868622386439249269795058985584353709739777081110979765232599757976759602245965314332404529910828253037394397471102918877473504943490285635862702543408002577628022054766664695619542702081689509713681170425764579507127909155563775027797744930354455708003402706090094588522963730499563711811899945647475596034599946875728770617584380135377604299815872040514361551864698426189453

f1 = open("chal.py","rb").read()
f2 = open("chal.enc","rb").read()

st = []
for a in range(0,256*2,256):
  q1 = f1[a:a+256]
  q2 = f2[a:a+256]
  q1 = bytes_to_long(q1)
  q2 = bytes_to_long(q2)
  stream = q1 ^ q2
  st.append(stream)

# e = 65537 and 65539

# sol 1: m^65539 / (m^65537) = m^2
buf = (st[1] * inverse(st[0],n)) % n
ans = (st[0] * inverse(pow(buf,32768,n),n)) % n
print (unpad(long_to_bytes(ans),255))

# sol 2: Common Modulus Attack
gcd, s0, s1 = gmpy2.gcdext(65537, 65539)
if s0 < 0:
  s0 = -s0
  st[0] = inverse(st[0], n)
elif s1 < 0:
  s1 = -s1
  st[1] = inverse(st[1], n)
v = pow(st[0], s0, n)
w = pow(st[1], s1, n)
ans = (v * w) % n
print (unpad(long_to_bytes(ans),255))

